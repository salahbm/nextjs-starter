You are my coding assistant. Follow these rules strictly for this project:

1. **File Naming**
   - Use kebab-case for all files and folders.

2. **Pages (Next.js)**
   - Pages live under `app/[locale]/...`.
   - Page file (`page.tsx`) contains ONLY:
     - SSR logic : metadata, headers, etc.
     - Data fetching
     - Passing data to a view component
   - Never put UI code directly inside a page.
   - Import and render the view from `components/views/...`.
   - Example:
     ```
     app/[locale]/(protected)/dashboard/page.tsx   <- SSR + data fetching
     components/views/dashboard/index.tsx          <- CSR view + UI
     ```

3. **View Components**
   - Each view gets its own folder under `components/views/{view-name}/`.
   - Export the main view from `index.tsx`.
   - Place subcomponents in `components/views/{view-name}/components/`.
   - Example:
     ```
     components/views/dashboard/index.tsx
     components/views/dashboard/components/chart.tsx
     ```

4. **Types**
   - For multiple types in a view, create `{view-name}.d.ts` in the same folder.

5. **Utils (Scoped)**
   - Place logic/helpers for a view in `components/views/{view-name}/utils/`.

6. **Shared (Scoped)**
   - If something is reused multiple times within a view, put it in `shared.ts` or `shared/` folder inside that view folder.

7. **Project-Wide Shared**
   - If reusable across the project:
     - Components → `components/shared/{name}/index.tsx` <- globally used components
     - Utils → `utils/{name}/` or `utils/{name}.ts` <- globally used utils
     - Styles → `styles/{name}.css` <- globally used styles
     - Types → `types/{name}.d.ts` <- globally used types
     - Constants → `constants/{name}.ts` <- globally used constants

8. **Forms**
   - Use `components/shared/form-fields/index.ts` as a wrapper for all input, select, date pickers, file uploads, etc.
   - Never use raw `<input>` directly in views unless unavoidable.
9. **Typography**
   - Always use classes from `styles/font.css` (`font-header` … `font-caption-2`).
     - These classes already define **font-size, weight, line-height**, and other text styles.
   - Avoid inline font styles (`font-size`, `font-weight`, `line-height`) unless absolutely unavoidable.
   - Do not create new font utility classes outside `styles/font.css`.
   - All headings, labels, captions, and body text must use these predefined classes.
10. **TypeScript**

- Never use `any`.
- Use `unknown` if unavoidable.
- Prefer Zod for runtime validation.

11. **Imports/Exports**

- Use absolute imports (`@/components/...`).
- Export from `index.ts` (barrel) for every folder.

12. **Code Quality**

- Small, focused components.
- Strict ESLint/Prettier rules.
- Separate concerns: SSR (pages) vs CSR (views).

13. **Forms**

- Always use the `FormFields` wrapper for every form input.
- Form structure must follow:
  - `react-hook-form` for control & validation
  - `zod` schemas for type-safe validation
  - `FormFields` props: `name`, `label`, `required`, `control`, `render`
  - Inside `render`, always spread `{...field}` on input
- Example pattern:
  ```tsx
  <FormFields
    name="email"
    label="Email"
    required
    control={form.control}
    render={({ field }) => (
      <Input placeholder="Enter email" type="email" {...field} />
    )}
  />
  ```
- For select/combobox/date:
  - Use shared components (`Combobox`, `DatePicker`, `Uploader`, etc.)
  - Always pass `value` + `onValueChange={field.onChange}` when component uses custom handlers.
- For message/help text:
  - Use `message` + `messageClassName="text-muted-foreground text-xs"` props on `FormFields`
- No direct `<input>`, `<select>`, `<textarea>`, or `<form>` usage without `FormFields`.
- Group related form fields inside a card or section with consistent spacing.
- Always wrap forms in a `<Form {...form}>` provider from `react-hook-form`.

14. **Tables**

- Always use the shared `DataTable` component from `components/shared/data-table`.
- Column definitions must be typed with `ColumnDef<T>` from `@tanstack/react-table`.
- Column headers use `DataTableColumnHeader` for sorting UI.
- Use `meta.label` for column names (helps with export, accessibility).
- Select column:
  - Use a `Checkbox` for row + header selection.
  - Keep selection state inside `react-table`'s table instance.
- Date columns:
  - Format with `date-fns` (`format(date, 'PPP')`).
  - Keep values as `Date` objects (parse from API if needed).
- Status columns:
  - Use a consistent `Badge` component with color mapping.
  - Store available statuses + colors in `statusOptions` array in same folder.
- Table state (pagination, sorting, filtering):
  - Use `useQueryReader` to read from URL query params.
  - Use `useQueryState` and `useDebounce` for search inputs.
  - Always sync pagination, sort, search state with URL (for deep-linking).
- Data fetching:
  - Use `useGetData(page, size, sort, search)` or similar hook per resource.
  - Return `{ data, paging }` so table knows `pageCount`.
- Table configuration:
  - Pass `pageCount` and `getRowId` to `useDataTable`.
  - Set `initialState.columnPinning.left = ['select']` if using selection.
- No inline tables — define `columns` in a separate `columns.ts` file per view.
- Table wrapper must include:
  - Search `<Input />` above table
  - Loader state (`<Loader />` when `isLoading`)

15. **Internationalization**

- Use `next-intl` for all translations.
- Supported locales: `en` (default) and `ru`.
- Always create translation files in `messages/{namespace}.json`.
- Use descriptive keys with dot-notation:
  - ✅ `dashboard.title`, `auth.login.button`
  - ❌ `dshb_ttl`, `btn1`
- Every page/view must have its own namespace (folder name = namespace).
- Import translations using `useTranslations(namespace)` in components.
- Do not hardcode strings — wrap them:
  ```tsx
  const t = useTranslations('dashboard');
  <h1>{t('title')}</h1>
  ```
- Keep message files alphabetically sorted for consistency.
- When adding new UI component:
  - Add translation keys to `en.json`
